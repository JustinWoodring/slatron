# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

Slatron is a distributed TV station manager with adaptive AI DJs and dynamic bumpers/transitions. It consists of three main components:
- **slatron-server** (Rust/Axum): Central server managing database, API, WebSockets, AI DJs, TTS, and bumper rendering
- **slatron-node** (Rust): Playback client controlling MPV via IPC, runs on display devices
- **slatron-ui** (React/Vite/TypeScript): Web dashboard for managing content, schedules, nodes, and bumpers

Default credentials: `admin` / `admin`

## Build & Development Commands

### Server (slatron-server)
```bash
cd slatron-server

# Standard build (without embedded UI)
cargo build --release

# Build with embedded UI (single binary deployment)
cargo build --release --features embed-ui

# Build with local Orpheus TTS support (embeds SNAC model)
cargo build --release --features ml-support

# Generate config template
cargo run --release -- --generate-config > config.toml

# Run server
cargo run --release

# Run with specific config
cargo run --release -- --config my_config.toml

# Run database migrations manually (auto-runs on startup)
diesel migration run

# Debug Rhai scripts
cargo run --bin debug_rhai
```

### Node (slatron-node)
```bash
cd slatron-node

# Build
cargo build --release

# Generate config template
cargo run --release -- --generate-config > config.toml

# Run node
cargo run --release

# Run with specific config
cargo run --release -- --config my_config.toml
```

### UI (slatron-ui)
```bash
cd slatron-ui

# Install dependencies
npm install

# Development server
npm run dev

# Production build (outputs to ../slatron-server/static)
npm run build

# Lint
npm run lint

# Preview production build
npm run preview
```

### Running Tests
```bash
# Server tests
cd slatron-server
cargo test

# Node tests (includes Rhai script tests)
cd slatron-node
cargo test
```

## Architecture & Key Patterns

### Server Architecture (slatron-server)

**Main Components:**
- `main.rs`: Application bootstrap, creates `AppState` with shared services
- `AppState`: Shared state containing DB pool, AI/TTS/Bumper/Script/DjDialogue services, WebSocket connections, node logs
- `api/`: REST API endpoints organized by domain (auth, content, schedules, nodes, djs, scripts, bumpers, spot_reels, settings)
- `services/`: Business logic layer
  - `ai/`: LLM provider adapters using trait-based pattern
    - `mod.rs`: Main service with `LlmProvider` trait
    - `ollama_adapter.rs`, `openai_adapter.rs`, `gemini_adapter.rs`, `anthropic_adapter.rs`
  - `tts/`: TTS provider adapters using trait-based pattern
    - `mod.rs`: Main service with `TtsProvider` trait
    - `orpheus_adapter.rs`: Local Orpheus TTS (LM Studio + SNAC)
    - `gemini_adapter.rs`: Gemini TTS API
    - `elevenlabs_adapter.rs`: Stub for future implementation
  - `bumper_service.rs`: MLT video rendering with template variable substitution
  - `dj_dialogue_service.rs`: DJ dialogue orchestration (memories, context scripts, prompt building, retry logic)
  - `schedule_service.rs`: Schedule resolution with priority-based collapsing
  - `script_service.rs`: Rhai script execution and caching
  - `heartbeat_monitor.rs`: Marks nodes offline after 30s of silence
- `websocket/`: WebSocket protocol for server↔node communication
- `rhai_engine/`: Rhai scripting engine with custom functions per script type
- `auth/`: JWT-based authentication with RBAC (Admin, Editor, Viewer)

**Database (Diesel ORM):**
- SQLite with auto-migrations on startup
- Schema defined in `schema.rs` (generated by Diesel CLI)
- Models in `models.rs` with custom timestamp serialization
- Key tables: users, nodes, schedules, schedule_blocks, content_items, dj_profiles, ai_providers, scripts, bumpers, spot_reels, spot_reel_items

**Build System:**
- `build.rs` handles two features:
  - `embed-ui`: Runs `npm run build` and zips UI into binary
  - `ml-support`: Embeds SNAC ONNX model for local Orpheus TTS

### Node Architecture (slatron-node)

**Main Components:**
- `main.rs`: Initializes `NodeState`, starts WebSocket client and playback loop
- `NodeState`: Shared state with schedule cache, MPV clients (main + voice), script cache, settings, bumper queue, spot reel cancellation token
- `websocket_client.rs`: WebSocket client handling authentication, heartbeats, commands
- `mpv_client.rs`: MPV IPC communication via JSON commands over Unix socket
- `playback.rs`: Playback loop executing schedule blocks, managing content transitions, spot reel detection
- `spot_reel_player.rs`: Spot reel playback loop — fetches reel from server API, cycles through items by type
- `web_capture.rs`: Web page capture pipeline (Xvfb + Chromium + FFmpeg x11grab), Linux only
- `schedule.rs`: Schedule caching and local resolution (works offline)
- `rhai_engine/`: Node-side Rhai engine with MPV overlay/control functions
- `heartbeat.rs`: Sends heartbeat every 5s with system metrics (CPU, memory, playback state)
- `screenshot.rs`: Captures MPV screenshots via IPC

**MPV Integration:**
- Two MPV instances: primary playback + voice overlay for DJ audio
- Communication via IPC socket (`/tmp/mpv-socket`)
- Commands: `loadfile`, `seek`, `set_property`, `overlay-add`, etc.

**Rhai Scripts on Node:**
- Three lifecycle hooks: `transform()`, `on_load()`, `on_unload()`
- Functions available: `mpv_overlay()`, `mpv_text()`, `set_volume()`, `set_loop()`, `download_file()`, `shell_execute()`
- Bumper functions (global scripts): `inject_bumper()`, `is_top_of_hour()`, `get_current_hour()`

### UI Architecture (slatron-ui)

**Structure:**
- `src/pages/`: Top-level page components (Dashboard, Schedules, Nodes, DJs, etc.)
- `src/components/`: Reusable components organized by feature
- `src/stores/`: Zustand stores for state management (auth, content, schedules, DJs, scripts)
- React Router for navigation
- TanStack Query for API data fetching
- Tailwind CSS for styling
- Monaco Editor for script editing

**Key Features:**
- ScheduleGrid: Drag-and-drop schedule editor with 15-minute time slots
- NodeLogs: Real-time log streaming via WebSocket
- LiveNodeGrid: Dashboard showing node status and screenshots

### Schedule System

**Priority Resolution:**
- Multiple schedules can be assigned to a node with different priorities
- `schedule_service.rs::calculate_collapsed_schedule()` creates a 1440-minute timeline
- Higher priority schedules override lower priority ones
- Priority can be overridden per-node in `node_schedules` table
- Schedule types: `recurring` (day-of-week), `one_off` (specific date)

**Schedule Blocks:**
- Each block has: start_time, duration_minutes, content_id, optional DJ, optional script
- Blocks can have different DJs than parent schedule
- Blocks support transformer scripts for dynamic behavior

### AI DJ System

**Architecture:**
- DJ Profiles stored in `dj_profiles` table with personality prompt and voice config
- Separate LLM and Voice providers (allows mixing e.g., Gemini LLM + Orpheus Voice)
- Context Scripts: Server-side Rhai scripts that inject context into DJ prompts
- Memories: DJ experiences stored in `dj_memories` with importance scores

**Voice Providers:**
- Gemini TTS: Cloud-based, high quality, uses standard voice names (Aoede, Charon, etc.)
- Orpheus: Local TTS via LM Studio, requires `ml-support` feature, uses character names (tara)

**DJ Execution Flow:**
1. Schedule determines when DJ should speak
2. Server executes context scripts to gather environment data
3. AI service calls LLM with personality + context + recent memories
4. Response parsed for text, emotion, memory importance
5. TTS service generates audio
6. Audio URL sent to node via WebSocket `InjectAudio` command
7. Node plays audio over content using secondary MPV instance

### Bumpers System

**Architecture:**
- Bumpers are station branding elements (idents, transitions, lower thirds) managed separately from content
- System uses a two-layer architecture:
  - **Bumper Backs**: Base video files or MLT-generated backgrounds (solid colors, gradients, animations)
  - **Bumper Templates**: MLT templates that overlay station branding on top of bumper backs
- Server renders both bumper backs and templates to MP4 videos
- Nodes download and cache bumpers locally in `~/.slatron/bumper_cache/`
- Global Rhai scripts can dynamically inject bumpers during playback

**Bumper Backs:**
- Base video layer that provides background animation or graphics
- Can be either:
  - MLT templates (simple animations like gradients, solid colors) stored as `.mlt` files
  - User-uploaded video files (.mp4, .mov, .webm, etc.)
  - Downloaded from remote URLs (e.g., from a repository)
- Stored in `bumper_backs` table with foreign key relationship to `bumpers`
- Rendered MLT backs stored in `static/media/bumper_backs/`

**Bumper Types:**
- `station_ident`: Station identification/branding clips
- `transition`: Transitions between content
- `show_opener`: Show intro bumpers
- `lower_third`: On-screen graphics/overlays
- `custom`: User-defined types

**Template Variables:**
- `{{STATION_NAME}}`: Substituted from `station_name` global setting
- `{{THEME_COLOR}}`: Substituted from `station_theme_color` global setting (hex color code)
- `{{BUMPER_BACK_PATH}}`: Path to the bumper back video (automatically resolved from `bumper_back_id`)

**MLT Rendering Process:**
1. **Bumper Back Rendering** (if using MLT-based back):
   - MLT file stored in `static/media/bumper_backs/*.mlt`
   - `BumperService::render_bumper_back()` renders MLT to MP4
   - Updates `bumper_backs` table with rendered path and duration
2. **Bumper Template Rendering**:
   - User creates/uploads MLT template via UI
   - Template stored in `bumpers` table with `is_template: true` and optional `bumper_back_id`
   - User triggers render (manual button or automatic on setting change)
   - `BumperService::render_template()` substitutes variables including bumper back path
   - Executes `melt` command to render final MP4 video (compositing back + branding)
   - Extracts duration with `ffprobe`
   - Updates database with `rendered_path`, `duration_ms`, `last_rendered_at`
   - File served from `static/media/bumpers/` via HTTP

**Bumper Injection Flow:**
1. Global script calls `inject_bumper("Station Ident")` during `on_load()` or `on_unload()`
2. Bumper name/ID added to `NodeState.bumper_queue`
3. Playback loop checks queue between content
4. Node fetches bumper metadata from `/api/bumpers` or `/api/bumpers/:id`
5. Downloads rendered video to local cache if not already cached
6. Plays bumper via main MPV instance (interrupts current content)
7. Waits for bumper duration before resuming schedule

**Default Bumper Backs:**
Three simple MLT-generated backgrounds seeded on startup:
- **Solid Blue**: Simple solid blue background (`#1a2a4a`)
- **Solid Purple**: Simple solid purple background
- **Solid Grey**: Simple solid grey background

**Default Bumpers:**
One built-in template seeded on startup:
- **Station Ident**: 5-second station name display overlaid on bumper back with theme color outline

**Default Global Script:**
"Auto Station Bumpers" - Automatically injects bumpers:
- Station ident at top of every hour (`is_top_of_hour()`)
- Transition between content during daytime hours (6 AM - 10 PM)

**Rhai Functions for Bumpers:**
- `inject_bumper(name_or_id)`: Queue bumper for playback (accepts name string or numeric ID)
- `is_top_of_hour()`: Returns true if current minute is :00
- `get_current_hour()`: Returns current hour (0-23) as integer

**Example Global Script:**
```rhai
fn on_load() {
    // Play station ident every hour
    if is_top_of_hour() {
        inject_bumper("Station Ident");
    }
}

fn on_unload() {
    // Play transition between content during daytime
    let hour = get_current_hour();
    if hour >= 6 && hour < 22 {
        inject_bumper("Transition");
    }
}
```

**API Endpoints:**

*Bumpers:*
- `GET /api/bumpers` - List all bumpers
- `POST /api/bumpers` - Create new bumper
- `GET /api/bumpers/:id` - Get specific bumper
- `PUT /api/bumpers/:id` - Update bumper
- `DELETE /api/bumpers/:id` - Delete bumper
- `POST /api/bumpers/:id/render` - Render single bumper template
- `POST /api/bumpers/render-all` - Render all bumper templates

*Bumper Backs:*
- `GET /api/bumper-backs` - List all bumper backs
- `POST /api/bumper-backs` - Create new bumper back
- `GET /api/bumper-backs/:id` - Get specific bumper back
- `PUT /api/bumper-backs/:id` - Update bumper back
- `DELETE /api/bumper-backs/:id` - Delete bumper back (prevents deletion if referenced)
- `POST /api/bumper-backs/:id/render` - Render single bumper back MLT
- `POST /api/bumper-backs/render-all` - Render all bumper back MLTs
- `POST /api/bumper-backs/fetch` - Download bumper back from remote URL
- `POST /api/bumper-backs/upload` - Upload bumper back video file (multipart)

**File Locations:**
- Bumper back MLT templates: `slatron-server/src/defaults/bumper_backs/*.mlt`
- Bumper templates: `slatron-server/src/defaults/bumpers/*.mlt`
- Rendered bumper back videos: `static/media/bumper_backs/*.mp4`
- Rendered bumper videos: `static/media/bumpers/*.mp4`
- Node cache: `~/.slatron/bumper_cache/*.mp4`
- Service: `slatron-server/src/services/bumper_service.rs`
- API: `slatron-server/src/api/bumper_api.rs`
- Node playback: `slatron-node/src/playback.rs::play_queued_bumpers()`

**Uploading/Fetching Bumper Backs:**

*Upload Example (curl):*
```bash
curl -X POST http://localhost:8080/api/bumper-backs/upload \
  -H "Authorization: Bearer $TOKEN" \
  -F "name=Cool Animation" \
  -F "file=@/path/to/video.mp4"
```

*Fetch from URL Example (curl):*
```bash
curl -X POST http://localhost:8080/api/bumper-backs/fetch \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "url": "https://example.com/bumper.mp4",
    "name": "Remote Bumper"
  }'
```

### Spot Reels System

**Architecture:**
- Spot Reels bundle small content items (images, short videos, web pages) into looping carousels
- Each reel has ordered items with individual display durations
- Creating a spot reel auto-creates a `content_items` row with `content_type = "spot_reel"` so it can be scheduled like any other content
- The node fetches reel data from the server API and cycles through items until the schedule block ends
- Transitions between items are hard cuts (instant switch)

**Database Tables:**
- `spot_reels`: id, title, description, created_at, updated_at
- `spot_reel_items`: id, spot_reel_id (FK CASCADE), item_type (CHECK 'image'|'video'|'web'), item_path, display_duration_secs (default 10), position, title, created_at, updated_at
- `content_items.spot_reel_id`: Nullable FK linking the auto-created content item back to its spot reel

**Item Types:**
- `image`: Static image displayed via MPV for configured duration (all platforms)
- `video`: Video file played via MPV, capped at display_duration_secs (all platforms)
- `web`: Web page captured to video via Xvfb + Chromium + FFmpeg x11grab pipeline (Linux only)

**Web Capture Pipeline (Linux only):**
- Implemented in `slatron-node/src/web_capture.rs`
- Requires: Xvfb, Chromium/Google Chrome, FFmpeg with x11grab support
- Process: Starts Xvfb on `:99` → launches Chromium in kiosk mode → captures with FFmpeg → caches result for 5 minutes
- Chrome binary search order: `chromium`, `chromium-browser`, `google-chrome`, `google-chrome-stable`
- Cache location: `~/.slatron/web_cache/`

**Spot Reel Playback Flow:**
1. Schedule block has a content_id pointing to a `content_type = "spot_reel"` content item
2. `playback.rs::play_content()` detects `content_type == "spot_reel"` in the content cache
3. Cancels any existing spot reel via `NodeState.spot_reel_cancel` cancellation token
4. Spawns `spot_reel_player::play_spot_reel()` with a new cancellation token
5. Player fetches reel metadata + items from `GET /api/spot-reels/:id`
6. Sorts items by position, loops through them:
   - Image: loads in MPV, waits display_duration_secs
   - Video: loads in MPV, waits for completion or display_duration_secs cap
   - Web: captures via web_capture pipeline, plays resulting video
7. Checks cancellation token between each item
8. Loop repeats until cancellation (schedule block ends or content changes)

**API Endpoints:**
- `GET /api/spot-reels` - List all spot reels (with item_count, total_duration, content_item_id)
- `POST /api/spot-reels` - Create spot reel (also creates content_items row)
- `GET /api/spot-reels/:id` - Get reel with items (public, used by nodes)
- `PUT /api/spot-reels/:id` - Update reel (syncs title/description to content_items)
- `DELETE /api/spot-reels/:id` - Delete reel (deletes content_items row first, cascade removes items)
- `POST /api/spot-reels/:id/items` - Add item to reel
- `PUT /api/spot-reels/:id/items/:item_id` - Update item
- `DELETE /api/spot-reels/:id/items/:item_id` - Remove item
- `PUT /api/spot-reels/:id/items/reorder` - Reorder items by position

**File Locations:**
- Server API: `slatron-server/src/api/spot_reel_api.rs`
- Server models: `slatron-server/src/models.rs` (SpotReel, SpotReelItem, etc.)
- Node player: `slatron-node/src/spot_reel_player.rs`
- Node web capture: `slatron-node/src/web_capture.rs`
- Node playback integration: `slatron-node/src/playback.rs`
- UI store: `slatron-ui/src/stores/spotReelStore.ts`
- UI pages: `slatron-ui/src/pages/SpotReelsPage.tsx`, `slatron-ui/src/pages/SpotReelEditorPage.tsx`
- Schedule grid (purple styling): `slatron-ui/src/components/ScheduleGrid/ScheduleBlock.tsx`, `ScheduleGrid.tsx`

**UI Features:**
- Card grid listing all spot reels with item count and total duration
- Full editor page at `/spot-reels/:id` with drag-to-reorder items
- Purple badge in content picker modal for spot reel content
- Purple/violet block styling on the schedule grid (distinct from cyan video blocks)

### Rhai Scripting

**Script Types:**
- `content_loader`: Import content from external sources (YouTube, RSS)
- `transformer`: Modify playback settings per-content (volume, loop, start/end time)
- `global`: Execute logic on playback events
- `context`: Inject data into DJ prompts (server-side)
- `overlay`: Add visual overlays during playback (deprecated in favor of `global`)

**Server vs Node Execution:**
- Server: content_loader, context scripts
- Node: transformer, global scripts with MPV control functions

**Common Gotchas:**
- Scripts cached in-memory, must invalidate cache on update
- JSON parsing overridden to use `serde_json` for better Unicode support
- Server scripts can use `shell_execute()` and `download_file()`
- Node scripts have access to MPV commands and overlay functions

### WebSocket Protocol

**Server → Node Messages:**
- `AuthResponse`: Authentication result with node_id
- `ScheduleUpdated`: Trigger schedule refresh
- `Command`: Playback commands (Play, Pause, LoadContent, InjectAudio, etc.)
- `HeartbeatAck`: Acknowledgment of heartbeat

**Node → Server Messages:**
- `Authenticate`: Initial handshake with secret_key
- `Heartbeat`: Periodic status update with metrics and playback position
- `Log`: Forwarded log entries for UI display
- `Screenshot`: Base64-encoded screenshot
- `ContentError`: Report playback errors

### Configuration

**Server Config (`config.toml`):**
```toml
[server]
host = "0.0.0.0"
port = 8080

[server.https]
enabled = false
cert_path = "certs/cert.pem"
key_path = "certs/key.pem"

[database]
url = "sqlite://data/slatron.db"

[jwt]
secret = "CHANGE_IN_PRODUCTION"
expiration_hours = 24

[logging]
level = "info"
```

**Node Config (`config.toml`):**
```toml
node_name = "Display 1"
server_url = "ws://server:8080/ws"
secret_key = "from-ui"
heartbeat_interval_secs = 5
mpv_socket_path = "/tmp/mpv-socket"
```

## Code Architecture Notes

### Provider Adapter Pattern (Recently Refactored)

Both TTS and AI services use trait-based adapter patterns for extensibility:

**TTS Providers** (`services/tts/`):
- Implement `TtsProvider` trait with `async fn generate_speech(...) -> Result<PathBuf>`
- Factory pattern in `TtsService::get_provider()` routes to correct adapter
- Adding new provider: Create new file implementing trait + add to factory match

**LLM Providers** (`services/ai/`):
- Implement `LlmProvider` trait with `async fn generate_completion(...) -> Result<String>`
- Factory pattern in `AiService::get_provider()` routes to correct adapter
- Adding new provider: Create new file implementing trait + add to factory match

**DJ Dialogue Service** (`services/dj_dialogue_service.rs`):
- Separated from AI service for clarity
- Orchestrates: memory retrieval → context scripts → prompt building → LLM call → memory persistence
- Uses `AiService` for LLM calls, `ScriptService` for context scripts
- Methods are composable and testable individually

**Example: Adding a New TTS Provider**
```rust
// 1. Create services/tts/azure_adapter.rs
pub struct AzureTtsAdapter { /* ... */ }

#[async_trait]
impl TtsProvider for AzureTtsAdapter {
    async fn generate_speech(&self, text: &str, config: TtsConfig, output_dir: &PathBuf) -> Result<PathBuf> {
        // Implementation
    }
}

// 2. Add to services/tts/mod.rs factory
"azure" => Ok(Box::new(AzureTtsAdapter::new(self.client.clone(), provider)?)),
```

## Development Workflow

### Adding a New API Endpoint
1. Add route handler in `slatron-server/src/api/{domain}_api.rs`
2. Add models if needed in `models.rs`
3. Update schema if DB changes needed (run `diesel migration generate {name}`)
4. Add route to router in `api/mod.rs`
5. Update UI store in `slatron-ui/src/stores/`
6. Create/update UI components

### Adding a New TTS or LLM Provider
1. Create new adapter file in `services/tts/` or `services/ai/`
2. Implement the appropriate trait (`TtsProvider` or `LlmProvider`)
3. Add to factory pattern in `mod.rs`
4. Test adapter independently
5. Add to provider type options in UI

### Adding a New Rhai Function
1. Server-side: Add to `slatron-server/src/rhai_engine/mod.rs` in appropriate `register_*_functions()`
2. Node-side: Add to `slatron-node/src/rhai_engine/mod.rs`
3. Document in README.md under "Scripting API Reference"

### Modifying Database Schema
1. Run `diesel migration generate {migration_name}` in slatron-server
2. Edit `up.sql` and `down.sql` in new migration directory
3. Run `diesel migration run` to apply
4. Update `models.rs` with new fields
5. Regenerate schema: `diesel print-schema > src/schema.rs`

### Modifying Default Settings or Scripts
**IMPORTANT**: After migration `2025-12-12-162200_cleanup_and_unique_scripts`, all settings and scripts were deleted and the seeding system was implemented in `slatron-server/src/seeding.rs`.

**Source of Truth**: `slatron-server/src/seeding.rs` is now the authoritative source for:
- Default global settings (`DEFAULT_SETTINGS` constant)
- Built-in scripts (`DEFAULT_SCRIPTS` constant)
- Default bumpers (`DEFAULT_BUMPERS` constant)
- Default admin user

**To add/remove/modify defaults:**
1. Edit `slatron-server/src/seeding.rs` directly
2. Modify the `DEFAULT_SETTINGS`, `DEFAULT_SCRIPTS`, or `DEFAULT_BUMPERS` arrays
3. For bumper templates, also update files in `src/defaults/bumpers/`
4. Restart the server (seeding runs automatically on startup)
5. DO NOT create new migrations to add/remove seed data

**How seeding works:**
- Runs on every server startup via `seed_defaults()` in `main.rs`
- Settings: Inserts if key doesn't exist (preserves user modifications)
- Scripts: Updates built-in scripts if they exist, inserts if they don't
- Bumpers: Updates built-in bumper templates if they exist, inserts if they don't
- Users: Creates admin user only if it doesn't exist

**Example: Removing unused settings**
```rust
// Bad: Creating a migration to delete settings
// Good: Just remove from DEFAULT_SETTINGS array in seeding.rs
const DEFAULT_SETTINGS: &[(&str, &str, &str)] = &[
    ("station_name", "Slatron TV", "The name of the station."),
    // Removed: default_transition_type, content_error_behavior, etc.
];
```

## Common Issues

### Build Issues
- **UI build fails during `cargo build --features embed-ui`**: Ensure npm is in PATH and `slatron-ui/node_modules` exists
- **ML support build fails**: Create `slatron-server/data/` and place `snac.onnx` model inside
- **Diesel migration errors**: Delete `slatron.db` and restart server for fresh DB

### Runtime Issues
- **Nodes appear offline**: Check WebSocket connection, verify secret_key matches
- **No audio from DJ**: Ensure voice provider is configured and `mpv` supports audio
- **Schedule not updating**: Server sends `ScheduleUpdated` message; check node logs for receipt
- **Scripts not executing**: Check script type matches usage context, verify no syntax errors in Rhai
- **Bumpers not rendering**: Ensure `melt` (MLT) and `ffprobe` (FFmpeg) are installed and in PATH
- **Bumpers not playing**: Check that bumper has been rendered (has `rendered_path`), verify node can access server static files
- **Spot reel not appearing in content picker**: Ensure the CHECK constraint migration has been applied (requires `'spot_reel'` in content_type CHECK). If the reel was created before the migration, the companion content_items row may be missing — delete and recreate the reel.
- **Spot reel web items failing**: Web capture requires Linux with Xvfb, Chromium, and FFmpeg with x11grab support. This does not work on macOS or Windows.

## Testing Notes
- Most tests are in `slatron-node/src/rhai_engine/tests.rs` (Rhai script tests)
- Server has minimal test coverage currently
- UI has no automated tests currently

## Dependencies & Tooling
- **Rust**: 1.75+ required
- **Node.js**: 18+ required for UI
- **Diesel CLI**: `cargo install diesel_cli --no-default-features --features sqlite`
- **MPV**: Must be installed on node systems (`brew install mpv` / `apt install mpv`)
- **MLT Framework**: Required for bumper rendering on server (`brew install mlt` / `apt install melt`)
- **FFmpeg**: Required for video duration extraction (`brew install ffmpeg` / `apt install ffmpeg`)
- **Xvfb**: Required for web capture in spot reels, Linux only (`apt install xvfb`)
- **Chromium/Chrome**: Required for web capture in spot reels, Linux only (`apt install chromium`)
- **tokio-util**: Used in node for `CancellationToken` (spot reel lifecycle)
- **sha2**: Used in node for web capture cache hashing
