# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

Slatron is a distributed TV station manager with adaptive AI DJs. It consists of three main components:
- **slatron-server** (Rust/Axum): Central server managing database, API, WebSockets, AI DJs, and TTS
- **slatron-node** (Rust): Playback client controlling MPV via IPC, runs on display devices
- **slatron-ui** (React/Vite/TypeScript): Web dashboard for managing content, schedules, and nodes

Default credentials: `admin` / `admin`

## Build & Development Commands

### Server (slatron-server)
```bash
cd slatron-server

# Standard build (without embedded UI)
cargo build --release

# Build with embedded UI (single binary deployment)
cargo build --release --features embed-ui

# Build with local Orpheus TTS support (embeds SNAC model)
cargo build --release --features ml-support

# Generate config template
cargo run --release -- --generate-config > config.toml

# Run server
cargo run --release

# Run with specific config
cargo run --release -- --config my_config.toml

# Run database migrations manually (auto-runs on startup)
diesel migration run

# Debug Rhai scripts
cargo run --bin debug_rhai
```

### Node (slatron-node)
```bash
cd slatron-node

# Build
cargo build --release

# Generate config template
cargo run --release -- --generate-config > config.toml

# Run node
cargo run --release

# Run with specific config
cargo run --release -- --config my_config.toml
```

### UI (slatron-ui)
```bash
cd slatron-ui

# Install dependencies
npm install

# Development server
npm run dev

# Production build (outputs to ../slatron-server/static)
npm run build

# Lint
npm run lint

# Preview production build
npm run preview
```

### Running Tests
```bash
# Server tests
cd slatron-server
cargo test

# Node tests (includes Rhai script tests)
cd slatron-node
cargo test
```

## Architecture & Key Patterns

### Server Architecture (slatron-server)

**Main Components:**
- `main.rs`: Application bootstrap, creates `AppState` with shared services
- `AppState`: Shared state containing DB pool, AI/TTS/Script/DjDialogue services, WebSocket connections, node logs
- `api/`: REST API endpoints organized by domain (auth, content, schedules, nodes, djs, scripts, settings)
- `services/`: Business logic layer
  - `ai/`: LLM provider adapters using trait-based pattern
    - `mod.rs`: Main service with `LlmProvider` trait
    - `ollama_adapter.rs`, `openai_adapter.rs`, `gemini_adapter.rs`, `anthropic_adapter.rs`
  - `tts/`: TTS provider adapters using trait-based pattern
    - `mod.rs`: Main service with `TtsProvider` trait
    - `orpheus_adapter.rs`: Local Orpheus TTS (LM Studio + SNAC)
    - `gemini_adapter.rs`: Gemini TTS API
    - `elevenlabs_adapter.rs`: Stub for future implementation
  - `dj_dialogue_service.rs`: DJ dialogue orchestration (memories, context scripts, prompt building, retry logic)
  - `schedule_service.rs`: Schedule resolution with priority-based collapsing
  - `script_service.rs`: Rhai script execution and caching
  - `heartbeat_monitor.rs`: Marks nodes offline after 30s of silence
- `websocket/`: WebSocket protocol for server↔node communication
- `rhai_engine/`: Rhai scripting engine with custom functions per script type
- `auth/`: JWT-based authentication with RBAC (Admin, Editor, Viewer)

**Database (Diesel ORM):**
- SQLite with auto-migrations on startup
- Schema defined in `schema.rs` (generated by Diesel CLI)
- Models in `models.rs` with custom timestamp serialization
- Key tables: users, nodes, schedules, schedule_blocks, content_items, dj_profiles, ai_providers, scripts

**Build System:**
- `build.rs` handles two features:
  - `embed-ui`: Runs `npm run build` and zips UI into binary
  - `ml-support`: Embeds SNAC ONNX model for local Orpheus TTS

### Node Architecture (slatron-node)

**Main Components:**
- `main.rs`: Initializes `NodeState`, starts WebSocket client and playback loop
- `NodeState`: Shared state with schedule cache, MPV clients (main + voice), script cache, settings
- `websocket_client.rs`: WebSocket client handling authentication, heartbeats, commands
- `mpv_client.rs`: MPV IPC communication via JSON commands over Unix socket
- `playback.rs`: Playback loop executing schedule blocks, managing content transitions
- `schedule.rs`: Schedule caching and local resolution (works offline)
- `rhai_engine/`: Node-side Rhai engine with MPV overlay/control functions
- `heartbeat.rs`: Sends heartbeat every 5s with system metrics (CPU, memory, playback state)
- `screenshot.rs`: Captures MPV screenshots via IPC

**MPV Integration:**
- Two MPV instances: primary playback + voice overlay for DJ audio
- Communication via IPC socket (`/tmp/mpv-socket`)
- Commands: `loadfile`, `seek`, `set_property`, `overlay-add`, etc.

**Rhai Scripts on Node:**
- Three lifecycle hooks: `transform()`, `on_load()`, `on_unload()`
- Functions available: `mpv_overlay()`, `mpv_text()`, `set_volume()`, `set_loop()`, `download_file()`, `shell_execute()`

### UI Architecture (slatron-ui)

**Structure:**
- `src/pages/`: Top-level page components (Dashboard, Schedules, Nodes, DJs, etc.)
- `src/components/`: Reusable components organized by feature
- `src/stores/`: Zustand stores for state management (auth, content, schedules, DJs, scripts)
- React Router for navigation
- TanStack Query for API data fetching
- Tailwind CSS for styling
- Monaco Editor for script editing

**Key Features:**
- ScheduleGrid: Drag-and-drop schedule editor with 15-minute time slots
- NodeLogs: Real-time log streaming via WebSocket
- LiveNodeGrid: Dashboard showing node status and screenshots

### Schedule System

**Priority Resolution:**
- Multiple schedules can be assigned to a node with different priorities
- `schedule_service.rs::calculate_collapsed_schedule()` creates a 1440-minute timeline
- Higher priority schedules override lower priority ones
- Priority can be overridden per-node in `node_schedules` table
- Schedule types: `recurring` (day-of-week), `one_off` (specific date)

**Schedule Blocks:**
- Each block has: start_time, duration_minutes, content_id, optional DJ, optional script
- Blocks can have different DJs than parent schedule
- Blocks support transformer scripts for dynamic behavior

### AI DJ System

**Architecture:**
- DJ Profiles stored in `dj_profiles` table with personality prompt and voice config
- Separate LLM and Voice providers (allows mixing e.g., Gemini LLM + Orpheus Voice)
- Context Scripts: Server-side Rhai scripts that inject context into DJ prompts
- Memories: DJ experiences stored in `dj_memories` with importance scores

**Voice Providers:**
- Gemini TTS: Cloud-based, high quality, uses standard voice names (Aoede, Charon, etc.)
- Orpheus: Local TTS via LM Studio, requires `ml-support` feature, uses character names (tara)

**DJ Execution Flow:**
1. Schedule determines when DJ should speak
2. Server executes context scripts to gather environment data
3. AI service calls LLM with personality + context + recent memories
4. Response parsed for text, emotion, memory importance
5. TTS service generates audio
6. Audio URL sent to node via WebSocket `InjectAudio` command
7. Node plays audio over content using secondary MPV instance

### Rhai Scripting

**Script Types:**
- `content_loader`: Import content from external sources (YouTube, RSS)
- `transformer`: Modify playback settings per-content (volume, loop, start/end time)
- `global`: Execute logic on playback events
- `context`: Inject data into DJ prompts (server-side)
- `overlay`: Add visual overlays during playback (deprecated in favor of `global`)

**Server vs Node Execution:**
- Server: content_loader, context scripts
- Node: transformer, global scripts with MPV control functions

**Common Gotchas:**
- Scripts cached in-memory, must invalidate cache on update
- JSON parsing overridden to use `serde_json` for better Unicode support
- Server scripts can use `shell_execute()` and `download_file()`
- Node scripts have access to MPV commands and overlay functions

### WebSocket Protocol

**Server → Node Messages:**
- `AuthResponse`: Authentication result with node_id
- `ScheduleUpdated`: Trigger schedule refresh
- `Command`: Playback commands (Play, Pause, LoadContent, InjectAudio, etc.)
- `HeartbeatAck`: Acknowledgment of heartbeat

**Node → Server Messages:**
- `Authenticate`: Initial handshake with secret_key
- `Heartbeat`: Periodic status update with metrics and playback position
- `Log`: Forwarded log entries for UI display
- `Screenshot`: Base64-encoded screenshot
- `ContentError`: Report playback errors

### Configuration

**Server Config (`config.toml`):**
```toml
[server]
host = "0.0.0.0"
port = 8080

[server.https]
enabled = false
cert_path = "certs/cert.pem"
key_path = "certs/key.pem"

[database]
url = "sqlite://data/slatron.db"

[jwt]
secret = "CHANGE_IN_PRODUCTION"
expiration_hours = 24

[logging]
level = "info"
```

**Node Config (`config.toml`):**
```toml
node_name = "Display 1"
server_url = "ws://server:8080/ws"
secret_key = "from-ui"
heartbeat_interval_secs = 5
mpv_socket_path = "/tmp/mpv-socket"
```

## Code Architecture Notes

### Provider Adapter Pattern (Recently Refactored)

Both TTS and AI services use trait-based adapter patterns for extensibility:

**TTS Providers** (`services/tts/`):
- Implement `TtsProvider` trait with `async fn generate_speech(...) -> Result<PathBuf>`
- Factory pattern in `TtsService::get_provider()` routes to correct adapter
- Adding new provider: Create new file implementing trait + add to factory match

**LLM Providers** (`services/ai/`):
- Implement `LlmProvider` trait with `async fn generate_completion(...) -> Result<String>`
- Factory pattern in `AiService::get_provider()` routes to correct adapter
- Adding new provider: Create new file implementing trait + add to factory match

**DJ Dialogue Service** (`services/dj_dialogue_service.rs`):
- Separated from AI service for clarity
- Orchestrates: memory retrieval → context scripts → prompt building → LLM call → memory persistence
- Uses `AiService` for LLM calls, `ScriptService` for context scripts
- Methods are composable and testable individually

**Example: Adding a New TTS Provider**
```rust
// 1. Create services/tts/azure_adapter.rs
pub struct AzureTtsAdapter { /* ... */ }

#[async_trait]
impl TtsProvider for AzureTtsAdapter {
    async fn generate_speech(&self, text: &str, config: TtsConfig, output_dir: &PathBuf) -> Result<PathBuf> {
        // Implementation
    }
}

// 2. Add to services/tts/mod.rs factory
"azure" => Ok(Box::new(AzureTtsAdapter::new(self.client.clone(), provider)?)),
```

## Development Workflow

### Adding a New API Endpoint
1. Add route handler in `slatron-server/src/api/{domain}_api.rs`
2. Add models if needed in `models.rs`
3. Update schema if DB changes needed (run `diesel migration generate {name}`)
4. Add route to router in `api/mod.rs`
5. Update UI store in `slatron-ui/src/stores/`
6. Create/update UI components

### Adding a New TTS or LLM Provider
1. Create new adapter file in `services/tts/` or `services/ai/`
2. Implement the appropriate trait (`TtsProvider` or `LlmProvider`)
3. Add to factory pattern in `mod.rs`
4. Test adapter independently
5. Add to provider type options in UI

### Adding a New Rhai Function
1. Server-side: Add to `slatron-server/src/rhai_engine/mod.rs` in appropriate `register_*_functions()`
2. Node-side: Add to `slatron-node/src/rhai_engine/mod.rs`
3. Document in README.md under "Scripting API Reference"

### Modifying Database Schema
1. Run `diesel migration generate {migration_name}` in slatron-server
2. Edit `up.sql` and `down.sql` in new migration directory
3. Run `diesel migration run` to apply
4. Update `models.rs` with new fields
5. Regenerate schema: `diesel print-schema > src/schema.rs`

### Modifying Default Settings or Scripts
**IMPORTANT**: After migration `2025-12-12-162200_cleanup_and_unique_scripts`, all settings and scripts were deleted and the seeding system was implemented in `slatron-server/src/seeding.rs`.

**Source of Truth**: `slatron-server/src/seeding.rs` is now the authoritative source for:
- Default global settings (`DEFAULT_SETTINGS` constant)
- Built-in scripts (`DEFAULT_SCRIPTS` constant)
- Default admin user

**To add/remove/modify defaults:**
1. Edit `slatron-server/src/seeding.rs` directly
2. Modify the `DEFAULT_SETTINGS` or `DEFAULT_SCRIPTS` arrays
3. Restart the server (seeding runs automatically on startup)
4. DO NOT create new migrations to add/remove seed data

**How seeding works:**
- Runs on every server startup via `seed_defaults()` in `main.rs`
- Settings: Inserts if key doesn't exist (preserves user modifications)
- Scripts: Updates built-in scripts if they exist, inserts if they don't
- Users: Creates admin user only if it doesn't exist

**Example: Removing unused settings**
```rust
// Bad: Creating a migration to delete settings
// Good: Just remove from DEFAULT_SETTINGS array in seeding.rs
const DEFAULT_SETTINGS: &[(&str, &str, &str)] = &[
    ("station_name", "Slatron TV", "The name of the station."),
    // Removed: default_transition_type, content_error_behavior, etc.
];
```

## Common Issues

### Build Issues
- **UI build fails during `cargo build --features embed-ui`**: Ensure npm is in PATH and `slatron-ui/node_modules` exists
- **ML support build fails**: Create `slatron-server/data/` and place `snac.onnx` model inside
- **Diesel migration errors**: Delete `slatron.db` and restart server for fresh DB

### Runtime Issues
- **Nodes appear offline**: Check WebSocket connection, verify secret_key matches
- **No audio from DJ**: Ensure voice provider is configured and `mpv` supports audio
- **Schedule not updating**: Server sends `ScheduleUpdated` message; check node logs for receipt
- **Scripts not executing**: Check script type matches usage context, verify no syntax errors in Rhai

## Testing Notes
- Most tests are in `slatron-node/src/rhai_engine/tests.rs` (Rhai script tests)
- Server has minimal test coverage currently
- UI has no automated tests currently

## Dependencies & Tooling
- **Rust**: 1.75+ required
- **Node.js**: 18+ required for UI
- **Diesel CLI**: `cargo install diesel_cli --no-default-features --features sqlite`
- **MPV**: Must be installed on node systems (`brew install mpv` / `apt install mpv`)
